(set-logic UFDTLIA)

(declare-datatypes ((Lst 0)) (((cons (head Int) (tail Lst)) (nil))))
(declare-datatypes ((Tree 0)) (((node (data Int) (left Tree) (right Tree)) (leaf))))
(declare-datatypes ((Pair 0)(ZLst 0)) (((mkpair (first Int) (second Int)))
    ((zcons (zhead Pair) (ztail ZLst)) (znil))))
(declare-fun less (Int Int) Bool)
(declare-fun plus (Int Int) Int)
(declare-fun mult (Int Int) Int)
(declare-fun qmult (Int Int Int) Int)
(declare-fun exp (Int Int) Int)
(declare-fun qexp (Int Int Int) Int)
(declare-fun fac (Int) Int)
(declare-fun qfac (Int Int) Int)
(declare-fun double (Int) Int)
(declare-fun half (Int) Int)
(declare-fun even (Int) Bool)
(declare-fun append (Lst Lst) Lst)
(declare-fun len (Lst) Int)
(declare-fun drop (Int Lst) Lst)
(declare-fun take (Int Lst) Lst)
(declare-fun count (Int Lst) Int)
(declare-fun mem (Int Lst) Bool)
(declare-fun rev (Lst) Lst)
(declare-fun qreva (Lst Lst) Lst)
(declare-fun insort (Int Lst) Lst)
(declare-fun sorted (Lst) Bool)
(declare-fun sort (Lst) Lst)
(declare-fun rotate (Int Lst) Lst)
(declare-fun revflat (Tree) Lst)
(declare-fun qrevaflat (Tree Lst) Lst)
(define-fun leq ((x Int) (y Int)) Bool (<= x y))
(assert (forall ((x Int)) (= (drop x nil) nil)))
(assert (forall ((x Lst)) (= (drop 0 x) x)))
(assert (forall ((x Int) (y Int) (z Lst)) (=> (>= x 0) (= (drop (+ x 1) (cons y z)) (drop x z)))))
(assert (not 
(forall ((u Int) (v Int) (w Int) (x Int) (y Int) (z Lst)) (=> (and (>= v 0) (>= w 0) (>= u 0)) (= (drop (+ 1 u) (drop v (drop (+ 1 w) (cons x (cons y z))))) (drop (+ 1 u) (drop v (drop w (cons x z)))))))  ; G57 
))
(check-sat)
